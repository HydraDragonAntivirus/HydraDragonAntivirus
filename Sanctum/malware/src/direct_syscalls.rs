use std::{arch::naked_asm, ffi::c_void, ptr::null_mut};

use windows::Win32::{
    Foundation::{HANDLE, UNICODE_STRING},
    System::{Threading::PROCESS_ALL_ACCESS, WindowsProgramming::CLIENT_ID},
};

pub fn open_process(pid: u32) -> Result<HANDLE, ()> {
    let mut client_id = CLIENT_ID {
        UniqueProcess: HANDLE(pid as *mut _),
        UniqueThread: HANDLE::default(),
    };

    let mut handle: *mut c_void = null_mut();

    let mut oa: ObjectAttributes = ObjectAttributes {
        length: size_of::<ObjectAttributes>() as u32,
        root_directory: HANDLE(null_mut()),
        object_name: null_mut(),
        attributes: 0,
        security_descriptor: null_mut(),
        security_quality_of_service: null_mut(),
    };

    nt_open_process(&mut handle, PROCESS_ALL_ACCESS.0, &mut oa, &mut client_id);

    if handle.is_null() {
        println!("HANDLE WAS NULL? {:?}", handle);
        return Err(());
    }

    Ok(HANDLE(handle))
}

#[unsafe(naked)]
extern "system" fn nt_open_process(
    phandle: *mut *mut c_void,
    mask: u32,
    p_obj_arrrs: *mut ObjectAttributes,
    p_client_id: &mut CLIENT_ID,
) {
    naked_asm!("mov r10, rcx", "mov eax, 0x26", "syscall", "ret",)
}

#[repr(C)]
pub struct ObjectAttributes {
    pub length: u32,
    pub root_directory: HANDLE,
    pub object_name: *const UNICODE_STRING,
    pub attributes: u32,
    pub security_descriptor: *const c_void,
    pub security_quality_of_service: *const c_void,
}
