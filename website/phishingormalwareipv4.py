import os
from pathlib import Path
from typing import Set, List
import ipaddress
from collections import defaultdict

def validate_ip(ip_str: str) -> bool:
    """
    Validate if the string is a valid IPv4 address or CIDR notation.

    Args:
        ip_str: IP address string to validate

    Returns:
        bool: True if valid IPv4 address or CIDR, False otherwise
    """
    try:
        if '/' in ip_str:
            ipaddress.ip_network(ip_str, strict=False)
        else:
            ipaddress.ip_address(ip_str)
        return True
    except ValueError:
        return False

def process_ip_files(input_dir: str = ".", output_dir: str = "cleaned") -> None:
    """
    Process IP address files by removing duplicates, whitelisted IPs,
    and applying a priority order to the malicious lists.

    Input files:
      - IPv4Malware.txt
      - IPv4PhishingActive.txt
      - IPv4PhishingInActive.txt
      - IPv4DDoS.txt
      - IPv4WhiteList.txt

    The script writes the following output files:
      - cleaned_IPv4Malware.txt
      - cleaned_IPv4PhishingActive.txt
      - cleaned_IPv4PhishingInActive.txt
      - cleaned_IPv4DDoS.txt
      - cleaned_IPv4WhiteList.txt
      - invalid_ips.txt (if invalid IPs are found)

    Priority Order (highest to lowest):
      1. IPv4PhishingActive
      2. IPv4PhishingInActive
      3. IPv4DDoS
      4. IPv4Malware

    Any IP that appears in a higher priority list is removed from the lower priority lists.

    Args:
        input_dir: Directory containing the IP files (default: current directory)
        output_dir: Directory where cleaned files will be saved (default: 'cleaned')
    """
    input_path = Path(input_dir).resolve()
    output_path = Path(output_dir).resolve()

    print(f"Input directory: {input_path}")
    print(f"Output directory: {output_path}")

    # Define file names
    malicious_ip_file = "IPv4Malware.txt"
    phishing_active_file = "IPv4PhishingActive.txt"
    phishing_inactive_file = "IPv4PhishingInActive.txt"
    ddos_ip_file = "IPv4DDoS.txt"
    whitelist_ip_file = "IPv4WhiteList.txt"

    # Report which files are found
    print("\nLooking for these files:")
    for file_name in [malicious_ip_file, phishing_active_file, phishing_inactive_file, ddos_ip_file, whitelist_ip_file]:
        file_path = input_path / file_name
        print(f"- {file_name}: {'Found' if file_path.exists() else 'Not found'}")

    # Create output directory if it doesn't exist
    output_path.mkdir(exist_ok=True)
    print(f"\nCreated output directory: {output_path}")

    # --- Process Whitelist IPs ---
    whitelist_ips: Set[str] = set()
    whitelist_networks: List[ipaddress.IPv4Network] = []

    try:
        with open(input_path / whitelist_ip_file, 'r', encoding='utf-8') as f:
            for line in f:
                ip_str = line.strip()
                if not ip_str or ip_str.startswith('#'):
                    continue
                if validate_ip(ip_str):
                    if '/' in ip_str:
                        whitelist_networks.append(ipaddress.ip_network(ip_str, strict=False))
                    else:
                        whitelist_ips.add(ip_str)
    except FileNotFoundError:
        print(f"Warning: {whitelist_ip_file} not found. Proceeding without whitelist.")

    # --- Process Malware IPs ---
    malicious_ips: Set[str] = set()
    invalid_ips: List[str] = []

    try:
        with open(input_path / malicious_ip_file, 'r', encoding='utf-8') as f:
            for line in f:
                ip_str = line.strip()
                if not ip_str or ip_str.startswith('#'):
                    continue

                if validate_ip(ip_str):
                    if '/' in ip_str:
                        network = ipaddress.ip_network(ip_str, strict=False)
                        if not any(network.overlaps(wn) for wn in whitelist_networks):
                            malicious_ips.add(ip_str)
                    else:
                        ip_obj = ipaddress.ip_address(ip_str)
                        if (ip_str not in whitelist_ips and 
                            not any(ip_obj in network for network in whitelist_networks)):
                            malicious_ips.add(ip_str)
                else:
                    invalid_ips.append(ip_str)
    except FileNotFoundError:
        print(f"Warning: {malicious_ip_file} not found.")

    # --- Process Phishing Active IPs ---
    phishing_active_ips: Set[str] = set()
    try:
        with open(input_path / phishing_active_file, 'r', encoding='utf-8') as f:
            for line in f:
                ip_str = line.strip()
                if not ip_str or ip_str.startswith('#'):
                    continue

                if validate_ip(ip_str):
                    if '/' in ip_str:
                        network = ipaddress.ip_network(ip_str, strict=False)
                        if not any(network.overlaps(wn) for wn in whitelist_networks):
                            phishing_active_ips.add(ip_str)
                    else:
                        ip_obj = ipaddress.ip_address(ip_str)
                        if (ip_str not in whitelist_ips and 
                            not any(ip_obj in network for network in whitelist_networks)):
                            phishing_active_ips.add(ip_str)
                else:
                    invalid_ips.append(ip_str)
    except FileNotFoundError:
        print(f"Warning: {phishing_active_file} not found.")

    # --- Process Phishing Inactive IPs ---
    phishing_inactive_ips: Set[str] = set()
    try:
        with open(input_path / phishing_inactive_file, 'r', encoding='utf-8') as f:
            for line in f:
                ip_str = line.strip()
                if not ip_str or ip_str.startswith('#'):
                    continue

                if validate_ip(ip_str):
                    if '/' in ip_str:
                        network = ipaddress.ip_network(ip_str, strict=False)
                        if not any(network.overlaps(wn) for wn in whitelist_networks):
                            phishing_inactive_ips.add(ip_str)
                    else:
                        ip_obj = ipaddress.ip_address(ip_str)
                        if (ip_str not in whitelist_ips and 
                            not any(ip_obj in network for network in whitelist_networks)):
                            phishing_inactive_ips.add(ip_str)
                else:
                    invalid_ips.append(ip_str)
    except FileNotFoundError:
        print(f"Warning: {phishing_inactive_file} not found.")

    # --- Process DDoS IPs ---
    ddos_ips: Set[str] = set()
    try:
        with open(input_path / ddos_ip_file, 'r', encoding='utf-8') as f:
            for line in f:
                ip_str = line.strip()
                if not ip_str or ip_str.startswith('#'):
                    continue

                if validate_ip(ip_str):
                    if '/' in ip_str:
                        network = ipaddress.ip_network(ip_str, strict=False)
                        if not any(network.overlaps(wn) for wn in whitelist_networks):
                            ddos_ips.add(ip_str)
                    else:
                        ip_obj = ipaddress.ip_address(ip_str)
                        if (ip_str not in whitelist_ips and 
                            not any(ip_obj in network for network in whitelist_networks)):
                            ddos_ips.add(ip_str)
                else:
                    invalid_ips.append(ip_str)
    except FileNotFoundError:
        print(f"Warning: {ddos_ip_file} not found.")

    # --- Apply Priority: Remove IPs from lower priority lists based on higher priority ones ---
    # Priority order (highest to lowest):
    # 1. phishing_active_ips (IPv4PhishingActive)
    # 2. phishing_inactive_ips (IPv4PhishingInActive)
    # 3. ddos_ips (IPv4DDoS)
    # 4. malicious_ips (IPv4Malware)
    
    ddos_ips -= phishing_active_ips
    ddos_ips -= phishing_inactive_ips

    malicious_ips -= phishing_active_ips
    malicious_ips -= phishing_inactive_ips
    malicious_ips -= ddos_ips

    # --- Write Processed IPs Back to Files ---
    def write_ips(filename: str, ip_set: Set[str]) -> None:
        if ip_set:
            output_file = output_path / filename
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write('\n'.join(sorted(ip_set, key=lambda ip: int(ipaddress.ip_network(ip, strict=False)[0]))))
            print(f"Created {output_file} with {len(ip_set)} unique IPs")

    write_ips(f"cleaned_{phishing_active_file}", phishing_active_ips)
    write_ips(f"cleaned_{phishing_inactive_file}", phishing_inactive_ips)
    write_ips(f"cleaned_{ddos_ip_file}", ddos_ips)
    write_ips(f"cleaned_{malicious_ip_file}", malicious_ips)

    # --- Write Whitelist File ---
    if whitelist_ips or whitelist_networks:
        output_file = output_path / f"cleaned_{whitelist_ip_file}"
        with open(output_file, 'w', encoding='utf-8') as f:
            # Write individual whitelist IPs first
            if whitelist_ips:
                f.write('\n'.join(sorted(whitelist_ips, key=lambda ip: int(ipaddress.ip_address(ip)))))
            # Then write networks (CIDR)
            if whitelist_networks:
                if whitelist_ips:
                    f.write('\n')
                f.write('\n'.join(str(network) for network in sorted(whitelist_networks, key=lambda n: int(n[0]))))
        print(f"Created {output_file} with {len(whitelist_ips)} individual IPs and {len(whitelist_networks)} networks")

    # --- Report Invalid IPs ---
    if invalid_ips:
        invalid_file = output_path / "invalid_ips.txt"
        with open(invalid_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(invalid_ips))
        print(f"\nWarning: Found {len(invalid_ips)} invalid IP addresses. See {invalid_file}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='Process IPv4 IP files (malware, phishing, ddos, whitelist) and remove duplicates.')
    parser.add_argument('--input-dir', default=".", help='Directory containing IP files')
    parser.add_argument('--output-dir', default="cleaned", help='Directory for cleaned files')
    
    args = parser.parse_args()
    process_ip_files(args.input_dir, args.output_dir)
