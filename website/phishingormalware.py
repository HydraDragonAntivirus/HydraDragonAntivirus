import os
from pathlib import Path
from typing import Dict, Set, List
import argparse

def process_domain_files(input_dir: str = ".", output_dir: str = "cleaned") -> None:
    """
    Process domain files by removing duplicates and whitelisted domains.
    
    Args:
        input_dir: Directory containing the domain files
        output_dir: Directory where cleaned files will be saved
    """
    # Define file names with priorities
    files_priority = [
        "SpamDomains.txt",
        "MiningDomains.txt",
        "AbuseDomains.txt",
        "PhishingDomains.txt",
        "MalwareMailDomains.txt",
        "MalwareDomains.txt"
    ]
    
    whitelist_files = [
        "WhiteListDomainsMail.txt",
        "WhiteListDomains.txt"
    ]
    
    # Create output directory if it doesn't exist
    output_path = Path(output_dir)
    output_path.mkdir(exist_ok=True)
    
    # Dictionary to store domains for each category
    domain_sets: Dict[str, Set[str]] = {}
    
    # Process whitelist domains
    whitelist_domains: Set[str] = set()
    for whitelist_file in whitelist_files:
        try:
            file_path = Path(input_dir) / whitelist_file
            with open(file_path, 'r', encoding='utf-8') as f:
                whitelist_domains.update(line.strip().lower() for line in f if line.strip())
        except FileNotFoundError:
            print(f"Warning: {whitelist_file} not found. Proceeding without it.")
    
    # Read all domain files
    for file_name in files_priority:
        try:
            file_path = Path(input_dir) / file_name
            with open(file_path, 'r', encoding='utf-8') as f:
                # Convert domains to lowercase for consistency
                domains = {line.strip().lower() for line in f if line.strip()}
                # Remove whitelisted domains
                domains -= whitelist_domains
                domain_sets[file_name] = domains
        except FileNotFoundError:
            print(f"Warning: {file_name} not found. Skipping.")
            domain_sets[file_name] = set()
    
    # Process domains according to priority
    for i, high_priority_file in enumerate(files_priority):
        if high_priority_file not in domain_sets:
            continue
        for low_priority_file in files_priority[i+1:]:
            if low_priority_file not in domain_sets:
                continue
            # Move duplicate domains to higher priority file
            duplicates = domain_sets[high_priority_file] & domain_sets[low_priority_file]
            # Remove duplicates from lower priority file
            domain_sets[low_priority_file] -= duplicates
    
    # Write processed domains back to files
    for file_name, domains in domain_sets.items():
        if domains:  # Only write files that have domains
            output_file = output_path / f"cleaned_{file_name}"
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write('\n'.join(sorted(domains)))
            print(f"Created {output_file} with {len(domains)} unique domains")
    
    # Write whitelist domains to cleaned file
    if whitelist_domains:
        for whitelist_file in whitelist_files:
            output_file = output_path / f"cleaned_{whitelist_file}"
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write('\n'.join(sorted(whitelist_domains)))
            print(f"Created {output_file} with {len(whitelist_domains)} domains")

def validate_domain(domain: str) -> bool:
    """
    Basic domain validation function.
    
    Args:
        domain: Domain name to validate
    
    Returns:
        bool: True if domain appears valid, False otherwise
    """
    if not domain or len(domain) > 253:
        return False
    
    # Check for basic domain format
    parts = domain.split('.')
    if len(parts) < 2:
        return False
    
    for part in parts:
        if not part or len(part) > 63:
            return False
        if not all(c.isalnum() or c == '-' for c in part):
            return False
        if part.startswith('-') or part.endswith('-'):
            return False
    
    return True

if __name__ == "__main__":    
    parser = argparse.ArgumentParser(description='Process domain files and remove duplicates.')
    parser.add_argument('--input-dir', default=".", help='Directory containing domain files')
    parser.add_argument('--output-dir', default="cleaned", help='Directory for cleaned files')
    
    args = parser.parse_args()
    process_domain_files(args.input_dir, args.output_dir)