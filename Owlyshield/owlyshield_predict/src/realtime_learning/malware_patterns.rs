//! Malware Pattern Matching Module
//!
//! Defines and matches specific malware family patterns (RAT, ransomware, etc.)

use crate::realtime_learning::api_tracker::ApiTracker;
use crate::realtime_learning::behavioral_signature::ThreatLevel;
use crate::process::ProcessRecord;
use serde::{Serialize, Deserialize};
use std::collections::HashSet;
use std::fs;

/// Known malware pattern types
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum PatternType {
    RAT,                    // Remote Access Trojan
    Ransomware,             // File encryption malware
    Keylogger,              // Keystroke logger
    Spyware,                // General spyware
    BankingTrojan,          // Banking credential stealer
    Backdoor,               // System backdoor
    Rootkit,                // Kernel-mode rootkit
    Worm,                   // Self-replicating malware
    Botnet,                 // Botnet client
    CredentialStealer,      // Password/token stealer
    Cryptominer,            // Cryptocurrency miner
    Dropper,                // Malware dropper/downloader
    FilelessMalware,        // Memory-only malware
    ProcessHollowing,       // Process hollowing technique
    DLLInjection,           // DLL injection technique
    ReflectiveLoading,      // Reflective DLL loading
}

/// A specific malware pattern definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MalwarePattern {
    pub pattern_type: PatternType,
    pub name: String,
    pub description: String,
    pub threat_level: ThreatLevel,

    // API requirements - ALL must be present
    pub mandatory_apis: Vec<String>,

    // API requirements - at least N must be present
    pub required_apis: (usize, Vec<String>), // (min_count, apis)

    // Category requirements
    pub required_categories: Vec<String>,

    // Behavioral indicators
    pub indicators: BehavioralIndicators,

    // File/DLL patterns
    pub suspicious_files: Vec<String>,
    pub suspicious_dlls: Vec<String>,

    // Network indicators
    pub network_indicators: NetworkIndicators,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BehavioralIndicators {
    pub min_files_encrypted: Option<usize>,
    pub min_files_deleted: Option<usize>,
    pub min_registry_modifications: Option<usize>,
    pub requires_keylogging: bool,
    pub requires_screen_capture: bool,
    pub requires_process_injection: bool,
    pub requires_privilege_escalation: bool,
    pub requires_persistence: bool,
    pub requires_anti_analysis: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkIndicators {
    pub requires_c2_communication: bool,
    pub min_network_connections: Option<usize>,
    pub suspicious_ports: Vec<u16>,
    pub requires_dns_tunneling: bool,
}

/// Pattern matcher engine
pub struct PatternMatcher {
    patterns: Vec<MalwarePattern>,
    #[allow(dead_code)]
    malapi_json_path: String,
}

impl PatternMatcher {
    pub fn new(malapi_json_path: &str) -> Self {
        let patterns = Self::create_default_patterns();

        PatternMatcher {
            patterns,
            malapi_json_path: malapi_json_path.to_string(),
        }
    }

    /// Create default malware patterns
    fn create_default_patterns() -> Vec<MalwarePattern> {
        vec![
            // RAT Pattern
            MalwarePattern {
                pattern_type: PatternType::RAT,
                name: "Remote Access Trojan".to_string(),
                description: "Full-featured RAT with keylogging, screen capture, and remote control".to_string(),
                threat_level: ThreatLevel::Critical,
                mandatory_apis: vec![
                    "WSAStartup".to_string(),
                    "Connect".to_string(),
                ],
                required_apis: (3, vec![
                    "GetAsyncKeyState".to_string(),
                    "SetWindowsHookExA".to_string(),
                    "BitBlt".to_string(),
                    "GetDC".to_string(),
                    "VirtualAllocEx".to_string(),
                    "WriteProcessMemory".to_string(),
                    "CreateRemoteThread".to_string(),
                ]),
                required_categories: vec![
                    "spying".to_string(),
                    "internet".to_string(),
                    "injection".to_string(),
                ],
                indicators: BehavioralIndicators {
                    min_files_encrypted: None,
                    min_files_deleted: None,
                    min_registry_modifications: Some(1),
                    requires_keylogging: true,
                    requires_screen_capture: false,
                    requires_process_injection: true,
                    requires_privilege_escalation: false,
                    requires_persistence: true,
                    requires_anti_analysis: false,
                },
                suspicious_files: vec![],
                suspicious_dlls: vec!["user32.dll".to_string(), "ws2_32.dll".to_string()],
                network_indicators: NetworkIndicators {
                    requires_c2_communication: true,
                    min_network_connections: Some(1),
                    suspicious_ports: vec![4444, 5555, 6666, 8080, 8888],
                    requires_dns_tunneling: false,
                },
            },

            // Ransomware Pattern
            MalwarePattern {
                pattern_type: PatternType::Ransomware,
                name: "File Encryption Ransomware".to_string(),
                description: "Encrypts files and demands ransom payment".to_string(),
                threat_level: ThreatLevel::Critical,
                mandatory_apis: vec![
                    "CryptAcquireContextA".to_string(),
                    "CryptGenRandom".to_string(),
                    "CryptEncrypt".to_string(),
                ],
                required_apis: (2, vec![
                    "CryptDeriveKey".to_string(),
                    "CryptCreateHash".to_string(),
                    "CryptHashData".to_string(),
                    "FindFirstFileA".to_string(),
                    "FindNextFileA".to_string(),
                ]),
                required_categories: vec![
                    "ransomware".to_string(),
                    "enumeration".to_string(),
                ],
                indicators: BehavioralIndicators {
                    min_files_encrypted: Some(20),
                    min_files_deleted: Some(5),
                    min_registry_modifications: None,
                    requires_keylogging: false,
                    requires_screen_capture: false,
                    requires_process_injection: false,
                    requires_privilege_escalation: false,
                    requires_persistence: false,
                    requires_anti_analysis: false,
                },
                suspicious_files: vec![],
                suspicious_dlls: vec!["advapi32.dll".to_string()],
                network_indicators: NetworkIndicators {
                    requires_c2_communication: true,
                    min_network_connections: Some(1),
                    suspicious_ports: vec![],
                    requires_dns_tunneling: false,
                },
            },

            // Keylogger Pattern
            MalwarePattern {
                pattern_type: PatternType::Keylogger,
                name: "Keylogger".to_string(),
                description: "Captures and logs keyboard input".to_string(),
                threat_level: ThreatLevel::High,
                mandatory_apis: vec![
                    "GetAsyncKeyState".to_string(),
                ],
                required_apis: (2, vec![
                    "SetWindowsHookExA".to_string(),
                    "CallNextHookEx".to_string(),
                    "GetKeyState".to_string(),
                    "GetForegroundWindow".to_string(),
                    "GetWindowTextA".to_string(),
                ]),
                required_categories: vec![
                    "spying".to_string(),
                ],
                indicators: BehavioralIndicators {
                    min_files_encrypted: None,
                    min_files_deleted: None,
                    min_registry_modifications: None,
                    requires_keylogging: true,
                    requires_screen_capture: false,
                    requires_process_injection: false,
                    requires_privilege_escalation: false,
                    requires_persistence: true,
                    requires_anti_analysis: false,
                },
                suspicious_files: vec![],
                suspicious_dlls: vec!["user32.dll".to_string()],
                network_indicators: NetworkIndicators {
                    requires_c2_communication: false,
                    min_network_connections: None,
                    suspicious_ports: vec![],
                    requires_dns_tunneling: false,
                },
            },

            // Banking Trojan Pattern
            MalwarePattern {
                pattern_type: PatternType::BankingTrojan,
                name: "Banking Trojan".to_string(),
                description: "Steals banking credentials through browser hooking and form grabbing".to_string(),
                threat_level: ThreatLevel::Critical,
                mandatory_apis: vec![
                    "SetWindowsHookExA".to_string(),
                    "InternetOpenA".to_string(),
                ],
                required_apis: (3, vec![
                    "GetAsyncKeyState".to_string(),
                    "HttpSendRequestA".to_string(),
                    "InternetReadFile".to_string(),
                    "GetForegroundWindow".to_string(),
                    "VirtualAllocEx".to_string(),
                    "WriteProcessMemory".to_string(),
                ]),
                required_categories: vec![
                    "spying".to_string(),
                    "internet".to_string(),
                    "injection".to_string(),
                ],
                indicators: BehavioralIndicators {
                    min_files_encrypted: None,
                    min_files_deleted: None,
                    min_registry_modifications: Some(1),
                    requires_keylogging: true,
                    requires_screen_capture: false,
                    requires_process_injection: true,
                    requires_privilege_escalation: false,
                    requires_persistence: true,
                    requires_anti_analysis: false,
                },
                suspicious_files: vec![],
                suspicious_dlls: vec!["wininet.dll".to_string(), "urlmon.dll".to_string()],
                network_indicators: NetworkIndicators {
                    requires_c2_communication: true,
                    min_network_connections: Some(1),
                    suspicious_ports: vec![],
                    requires_dns_tunneling: false,
                },
            },

            // Credential Stealer Pattern
            MalwarePattern {
                pattern_type: PatternType::CredentialStealer,
                name: "Credential Stealer".to_string(),
                description: "Dumps credentials from LSASS, browsers, or credential managers".to_string(),
                threat_level: ThreatLevel::Critical,
                mandatory_apis: vec![
                    "OpenProcess".to_string(),
                    "ReadProcessMemory".to_string(),
                ],
                required_apis: (2, vec![
                    "CreateToolhelp32Snapshot".to_string(),
                    "Process32First".to_string(),
                    "Process32Next".to_string(),
                    "AdjustTokenPrivileges".to_string(),
                    "LookupPrivilegeValueA".to_string(),
                ]),
                required_categories: vec![
                    "enumeration".to_string(),
                    "helper".to_string(),
                ],
                indicators: BehavioralIndicators {
                    min_files_encrypted: None,
                    min_files_deleted: None,
                    min_registry_modifications: None,
                    requires_keylogging: false,
                    requires_screen_capture: false,
                    requires_process_injection: false,
                    requires_privilege_escalation: true,
                    requires_persistence: false,
                    requires_anti_analysis: false,
                },
                suspicious_files: vec!["lsass".to_string()],
                suspicious_dlls: vec!["samlib.dll".to_string(), "lsasrv.dll".to_string()],
                network_indicators: NetworkIndicators {
                    requires_c2_communication: false,
                    min_network_connections: None,
                    suspicious_ports: vec![],
                    requires_dns_tunneling: false,
                },
            },

            // Process Hollowing Pattern
            MalwarePattern {
                pattern_type: PatternType::ProcessHollowing,
                name: "Process Hollowing".to_string(),
                description: "Creates suspended process and replaces its memory with malicious code".to_string(),
                threat_level: ThreatLevel::High,
                mandatory_apis: vec![
                    "CreateProcessA".to_string(),
                    "NtUnmapViewOfSection".to_string(),
                    "VirtualAllocEx".to_string(),
                    "WriteProcessMemory".to_string(),
                    "SetThreadContext".to_string(),
                    "ResumeThread".to_string(),
                ],
                required_apis: (0, vec![]),
                required_categories: vec![
                    "injection".to_string(),
                ],
                indicators: BehavioralIndicators {
                    min_files_encrypted: None,
                    min_files_deleted: None,
                    min_registry_modifications: None,
                    requires_keylogging: false,
                    requires_screen_capture: false,
                    requires_process_injection: true,
                    requires_privilege_escalation: false,
                    requires_persistence: false,
                    requires_anti_analysis: false,
                },
                suspicious_files: vec![],
                suspicious_dlls: vec![],
                network_indicators: NetworkIndicators {
                    requires_c2_communication: false,
                    min_network_connections: None,
                    suspicious_ports: vec![],
                    requires_dns_tunneling: false,
                },
            },

            // Cryptominer Pattern
            MalwarePattern {
                pattern_type: PatternType::Cryptominer,
                name: "Cryptocurrency Miner".to_string(),
                description: "Uses system resources for cryptocurrency mining".to_string(),
                threat_level: ThreatLevel::Medium,
                mandatory_apis: vec![
                    "CreateThread".to_string(),
                ],
                required_apis: (2, vec![
                    "WSAStartup".to_string(),
                    "Connect".to_string(),
                    "VirtualAlloc".to_string(),
                    "SetThreadPriority".to_string(),
                ]),
                required_categories: vec![
                    "internet".to_string(),
                ],
                indicators: BehavioralIndicators {
                    min_files_encrypted: None,
                    min_files_deleted: None,
                    min_registry_modifications: Some(1),
                    requires_keylogging: false,
                    requires_screen_capture: false,
                    requires_process_injection: false,
                    requires_privilege_escalation: false,
                    requires_persistence: true,
                    requires_anti_analysis: true,
                },
                suspicious_files: vec![],
                suspicious_dlls: vec!["ws2_32.dll".to_string()],
                network_indicators: NetworkIndicators {
                    requires_c2_communication: true,
                    min_network_connections: Some(1),
                    suspicious_ports: vec![3333, 4444, 5555],
                    requires_dns_tunneling: false,
                },
            },

            // Botnet Pattern
            MalwarePattern {
                pattern_type: PatternType::Botnet,
                name: "Botnet Client".to_string(),
                description: "Connects to C2 server for remote commands".to_string(),
                threat_level: ThreatLevel::Critical,
                mandatory_apis: vec![
                    "WSAStartup".to_string(),
                    "Socket".to_string(),
                    "Connect".to_string(),
                ],
                required_apis: (2, vec![
                    "Send".to_string(),
                    "Recv".to_string(),
                    "CreateProcessA".to_string(),
                    "ShellExecuteA".to_string(),
                ]),
                required_categories: vec![
                    "internet".to_string(),
                    "helper".to_string(),
                ],
                indicators: BehavioralIndicators {
                    min_files_encrypted: None,
                    min_files_deleted: None,
                    min_registry_modifications: Some(1),
                    requires_keylogging: false,
                    requires_screen_capture: false,
                    requires_process_injection: false,
                    requires_privilege_escalation: false,
                    requires_persistence: true,
                    requires_anti_analysis: false,
                },
                suspicious_files: vec![],
                suspicious_dlls: vec!["ws2_32.dll".to_string()],
                network_indicators: NetworkIndicators {
                    requires_c2_communication: true,
                    min_network_connections: Some(1),
                    suspicious_ports: vec![],
                    requires_dns_tunneling: false,
                },
            },
        ]
    }

    /// Match a process against all patterns
    pub fn match_pattern(&self, api_tracker: &ApiTracker, precord: &ProcessRecord) -> Option<PatternType> {
        for pattern in &self.patterns {
            if self.check_pattern(pattern, api_tracker, precord) {
                return Some(pattern.pattern_type.clone());
            }
        }
        None
    }

    /// Get all matched patterns
    pub fn get_matched_patterns(&self, api_tracker: &ApiTracker) -> Vec<PatternType> {
        let mut matches = Vec::new();

        // Create dummy ProcessRecord for checking
        let dummy_precord = ProcessRecord::new(
            api_tracker.gid,
            String::new(),
            std::path::PathBuf::new(),
        );

        for pattern in &self.patterns {
            if self.check_pattern(pattern, api_tracker, &dummy_precord) {
                matches.push(pattern.pattern_type.clone());
            }
        }

        matches
    }

    /// Check if a pattern matches
    fn check_pattern(
        &self,
        pattern: &MalwarePattern,
        api_tracker: &ApiTracker,
        _precord: &ProcessRecord,
    ) -> bool {
        // Check mandatory APIs - ALL must be present
        for api in &pattern.mandatory_apis {
            if !self.has_api(api_tracker, api) {
                return false;
            }
        }

        // Check required APIs - at least N must be present
        let (min_count, required_apis) = &pattern.required_apis;
        let matched_count = required_apis.iter()
            .filter(|api| self.has_api(api_tracker, api))
            .count();

        if matched_count < *min_count {
            return false;
        }

        // Check required categories
        for category in &pattern.required_categories {
            if !self.has_category(api_tracker, category) {
                return false;
            }
        }

        // Check behavioral indicators
        if let Some(min_encrypted) = pattern.indicators.min_files_encrypted {
            if api_tracker.file_operations.files_encrypted < min_encrypted {
                return false;
            }
        }

        if let Some(min_deleted) = pattern.indicators.min_files_deleted {
            if api_tracker.file_operations.files_deleted < min_deleted {
                return false;
            }
        }

        if pattern.indicators.requires_keylogging {
            if !self.has_keylogging_apis(api_tracker) {
                return false;
            }
        }

        if pattern.indicators.requires_process_injection {
            if !self.has_injection_pattern(api_tracker) {
                return false;
            }
        }

        if pattern.indicators.requires_persistence {
            if !self.has_persistence_indicators(api_tracker) {
                return false;
            }
        }

        // Check network indicators
        if pattern.network_indicators.requires_c2_communication {
            if api_tracker.internet_apis.is_empty() {
                return false;
            }
        }

        true
    }

    fn has_api(&self, api_tracker: &ApiTracker, api: &str) -> bool {
        let all_apis: HashSet<String> = api_tracker.enumeration_apis.iter()
            .chain(api_tracker.injection_apis.iter())
            .chain(api_tracker.evasion_apis.iter())
            .chain(api_tracker.spying_apis.iter())
            .chain(api_tracker.internet_apis.iter())
            .chain(api_tracker.anti_debugging_apis.iter())
            .chain(api_tracker.ransomware_apis.iter())
            .chain(api_tracker.helper_apis.iter())
            .cloned()
            .collect();

        all_apis.contains(api)
    }

    fn has_category(&self, api_tracker: &ApiTracker, category: &str) -> bool {
        match category {
            "enumeration" => !api_tracker.enumeration_apis.is_empty(),
            "injection" => !api_tracker.injection_apis.is_empty(),
            "evasion" => !api_tracker.evasion_apis.is_empty(),
            "spying" => !api_tracker.spying_apis.is_empty(),
            "internet" => !api_tracker.internet_apis.is_empty(),
            "anti-debugging" => !api_tracker.anti_debugging_apis.is_empty(),
            "ransomware" => !api_tracker.ransomware_apis.is_empty(),
            "helper" => !api_tracker.helper_apis.is_empty(),
            _ => false,
        }
    }

    fn has_keylogging_apis(&self, api_tracker: &ApiTracker) -> bool {
        let keylog_apis = ["GetAsyncKeyState", "SetWindowsHookExA", "GetKeyState"];
        keylog_apis.iter().any(|api| api_tracker.spying_apis.contains(*api))
    }

    fn has_injection_pattern(&self, api_tracker: &ApiTracker) -> bool {
        let injection_apis = vec![
            "VirtualAllocEx", "WriteProcessMemory", "CreateRemoteThread",
            "NtCreateThreadEx", "QueueUserAPC"
        ];

        let matched = injection_apis.iter()
            .filter(|api| api_tracker.injection_apis.contains(&api.to_string()))
            .count();

        matched >= 2
    }

    fn has_persistence_indicators(&self, api_tracker: &ApiTracker) -> bool {
        let persistence_apis = vec![
            "RegCreateKeyExA", "RegSetValueExA", "CreateServiceA",
            "RegCreateKeyA", "RegSetKeyValueA"
        ];

        persistence_apis.iter().any(|api| api_tracker.helper_apis.contains(*api))
            || api_tracker.registry_operations.autorun_keys_modified
    }

    /// Add custom pattern
    pub fn add_pattern(&mut self, pattern: MalwarePattern) {
        self.patterns.push(pattern);
    }

    /// Load patterns from JSON file
    pub fn load_patterns_from_file(&mut self, path: &str) -> Result<(), std::io::Error> {
        let content = fs::read_to_string(path)?;
        let patterns: Vec<MalwarePattern> = serde_json::from_str(&content)?;
        self.patterns.extend(patterns);
        Ok(())
    }
}
