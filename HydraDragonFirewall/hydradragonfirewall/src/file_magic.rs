use std::sync::Arc;

#[derive(Clone, Debug)]
pub struct MagicSignature {
    pub magic: Vec<u8>,
    pub file_type: String,
    pub offset: usize,
}

pub struct FileMagicChecker {
    signatures: Vec<MagicSignature>,
}

impl FileMagicChecker {
    pub fn new() -> Self {
        // Initialize with the user-provided list
        let mut checker = Self {
            signatures: Vec::new(),
        };
        checker.load_default_signatures();
        checker
    }

    pub fn check(&self, data: &[u8]) -> Option<String> {
        if data.is_empty() {
            return None;
        }

        // We search for the first match. Order matters if there are overlapping prefixes, 
        // but robust signatures usually are distinct enough. 
        // We'll iterate through our list.
        for sig in &self.signatures {
            if data.len() >= sig.offset + sig.magic.len() {
                if &data[sig.offset..sig.offset + sig.magic.len()] == sig.magic.as_slice() {
                    return Some(sig.file_type.clone());
                }
            }
        }
        None
    }

    fn load_default_signatures(&mut self) {
        let raw_sigs = vec![
            (vec![0x23, 0x21], "sh"),
            (vec![0x02, 0x00, 0x5A, 0x57, 0x52, 0x54], "cwk"),
            (vec![0x00, 0x00, 0x02, 0x00, 0x06, 0x04, 0x06, 0x00], "wk1"),
            (vec![0x00, 0x00, 0x1A, 0x00, 0x00, 0x10, 0x04, 0x00], "wk3"),
            (vec![0x00, 0x00, 0x1A, 0x00, 0x02, 0x10, 0x04, 0x00], "wk4"),
            (vec![0x00, 0x00, 0x1A, 0x00, 0x05, 0x10, 0x04], "123"),
            (vec![0x00, 0x00, 0x03, 0xF3], "amiga"),
            (vec![0x00, 0x00, 0x49, 0x49, 0x58, 0x50, 0x52], "qxd"),
            (vec![0x50, 0x57, 0x53, 0x33], "psafe3"),
            (vec![0xD4, 0xC3, 0xB2, 0xA1], "pcap"),
            (vec![0x4D, 0x3C, 0xB2, 0xA1], "pcap"),
            (vec![0x0A, 0x0D, 0x0D, 0x0A], "pcapng"),
            (vec![0xED, 0xAB, 0xEE, 0xDB], "rpm"),
            (vec![0x53, 0x51, 0x4C, 0x69, 0x74, 0x65, 0x20, 0x66], "sqlite"),
            (vec![0x53, 0x50, 0x30, 0x31], "bin"),
            (vec![0x49, 0x57, 0x41, 0x44], "wad"),
            (vec![0x00], "pic"), 
            (vec![0xBE, 0xBA, 0xFE, 0xCA], "dba"),
            (vec![0x00, 0x01, 0x42, 0x44], "dba"),
            (vec![0x00, 0x01, 0x44, 0x54], "tda"),
            (vec![0x54, 0x44, 0x46, 0x24], "tdf"),
            (vec![0x54, 0x44, 0x45, 0x46], "tdef"),
            (vec![0x00, 0x01, 0x00, 0x00], "palm"),
            (vec![0x00, 0x00, 0x01, 0x00], "ico"),
            (vec![0x69, 0x63, 0x6E, 0x73], "icns"),
            (vec![0x66, 0x74, 0x79, 0x70, 0x33, 0x67], "3gp"),
            (vec![0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63], "heic"),
            (vec![0x1F, 0x9D], "z"),
            (vec![0x1F, 0xA0], "z"),
            (vec![0x2D, 0x68, 0x6C, 0x30, 0x2D], "lzh"),
            (vec![0x42, 0x41, 0x43, 0x4B, 0x4D, 0x49, 0x4B, 0x45], "bac"),
            (vec![0x49, 0x4E, 0x44, 0x58], "idx"),
            (vec![0x62, 0x70, 0x6C, 0x69, 0x73, 0x74], "plist"),
            (vec![0x42, 0x5A, 0x68], "bz2"),
            (vec![0x47, 0x49, 0x46, 0x38, 0x37, 0x61], "gif"),
            (vec![0x47, 0x49, 0x46, 0x38, 0x39, 0x61], "gif"),
            (vec![0x49, 0x49, 0x2A, 0x00], "tif"),
            (vec![0x4D, 0x4D, 0x00, 0x2A], "tif"),
            (vec![0x49, 0x49, 0x2A, 0x00, 0x10, 0x00, 0x00, 0x00], "cr2"),
            (vec![0x80, 0x2A, 0x5F, 0xD7], "cin"),
            (vec![0x52, 0x4E, 0x43, 0x01], "rnc"),
            (vec![0x4E, 0x55, 0x52, 0x55, 0x49, 0x4D, 0x47], "nui"),
            (vec![0x53, 0x44, 0x50, 0x58], "dpx"),
            (vec![0x76, 0x2F, 0x31, 0x01], "exr"),
            (vec![0x42, 0x50, 0x47, 0xFB], "bpg"),
            (vec![0xFF, 0xD8, 0xFF, 0xDB], "jpg"),
            (vec![0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46], "jpg"),
            (vec![0xFF, 0xD8, 0xFF, 0xEE], "jpg"),
            (vec![0xFF, 0xD8, 0xFF, 0xE1], "jpg"),
            (vec![0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20], "jp2"),
            (vec![0xFF, 0x4F, 0xFF, 0x51], "jp2"),
            (vec![0x71, 0x6F, 0x69, 0x66], "qoi"),
            (vec![0x46, 0x4F, 0x52, 0x4D], "ilbm"),
            (vec![0x4C, 0x5A, 0x49, 0x50], "lz"),
            (vec![0x30, 0x37, 0x30, 0x37, 0x30, 0x37], "cpio"),
            (vec![0x4D, 0x5A], "exe"),
            (vec![0x53, 0x4D, 0x53, 0x4E, 0x46, 0x32, 0x30, 0x30], "ssp"),
            (vec![0x5A, 0x4D], "exe"),
            (vec![0x50, 0x4B, 0x03, 0x04], "zip"),
            (vec![0x52, 0x61, 0x72, 0x21, 0x1A, 0x07, 0x00], "rar"),
            (vec![0x52, 0x61, 0x72, 0x21, 0x1A, 0x07, 0x01, 0x00], "rar"),
            (vec![0x7F, 0x45, 0x4C, 0x46], "elf"),
            (vec![0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A], "png"),
            (vec![0x0E, 0x03, 0x13, 0x01], "hdf4"),
            (vec![0x89, 0x48, 0x44, 0x46, 0x0D, 0x0A, 0x1A, 0x0A], "hdf5"),
            (vec![0xC9], "com"),
            (vec![0xCA, 0xFE, 0xBA, 0xBE], "class"),
            (vec![0xEF, 0xBB, 0xBF], "txt"),
            (vec![0xFF, 0xFE], "txt"),
            (vec![0xFE, 0xFF], "txt"),
            (vec![0xFF, 0xFE, 0x00, 0x00], "txt"),
            (vec![0x00, 0x00, 0xFE, 0xFF], "txt"),
            (vec![0x2B, 0x2F, 0x76, 0x38], "txt"),
            (vec![0x0E, 0xFE, 0xFF], "txt"),
            (vec![0xDD, 0x73, 0x66, 0x73], "txt"),
            (vec![0xFE, 0xED, 0xFA, 0xCE], "macho"),
            (vec![0xFE, 0xED, 0xFA, 0xCF], "macho"),
            (vec![0xFE, 0xED, 0xFE, 0xED], "jks"),
            (vec![0xCE, 0xFA, 0xED, 0xFE], "macho"),
            (vec![0xCF, 0xFA, 0xED, 0xFE], "macho"),
            (vec![0x25, 0x21, 0x50, 0x53], "ps"),
            (vec![0x25, 0x50, 0x44, 0x46, 0x2D], "pdf"),
            (vec![0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11], "asf"),
            (vec![0x24, 0x53, 0x44, 0x49, 0x30, 0x30, 0x30, 0x31], "sdi"),
            (vec![0x4F, 0x67, 0x67, 0x53], "ogg"),
            (vec![0x38, 0x42, 0x50, 0x53], "psd"),
            (vec![0x52, 0x49, 0x46, 0x46], "avi"),
            (vec![0xFF, 0xFB], "mp3"),
            (vec![0x49, 0x44, 0x33], "mp3"),
            (vec![0x42, 0x4D], "bmp"),
            (vec![0x43, 0x44, 0x30, 0x30, 0x31], "iso"),
            (vec![0x4C, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00], "lnk"),
            (vec![0x62, 0x6F, 0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00], "alias"),
            (vec![0x75, 0x73, 0x74, 0x61, 0x72, 0x00, 0x30, 0x30], "tar"),
            (vec![0x4D, 0x53, 0x43, 0x46], "cab"),
            (vec![0x4B, 0x44, 0x4D], "vmdk"),
            (vec![0x43, 0x72, 0x32, 0x34], "crx"),
            (vec![0x41, 0x47, 0x44, 0x33], "fh8"),
            (vec![0x05, 0x07, 0x00, 0x00, 0x42, 0x4F, 0x42, 0x4F], "cwk"),
            (vec![0x00, 0x00, 0x00, 0x14, 0x66, 0x74, 0x79, 0x70], "mov"),
            (vec![0x4D, 0x54, 0x68, 0x64], "mid"),
            (vec![0x4D, 0x41, 0x52, 0x31, 0x00], "mar"),
            (vec![0x4E, 0x45, 0x53, 0x1A], "nes"),
            (vec![0x75, 0x73, 0x74, 0x61, 0x72], "tar"), // "tar since time is important..."
        ];

        // Sort by length descending to match longest specific signatures first
        // (Naive approach, usually works for magic numbers)
        // Actually, some user types duplicates with different magic.
        for (magic, ftype) in raw_sigs {
            self.addItem(magic, ftype.to_string());
        }
        
        // Ensure we sort so we don't return "dos" for "exe" if "exe" is longer/better
        // The loop check order matters.
        self.signatures.sort_by(|a, b| b.magic.len().cmp(&a.magic.len()));
    }
    
    fn addItem(&mut self, magic: Vec<u8>, file_type: String) {
        self.signatures.push(MagicSignature {
            magic,
            file_type,
            offset: 0,
        });
    }
}
