import os
from pathlib import Path
from typing import Dict, Set, List
import ipaddress
from collections import defaultdict

def validate_ip(ip_str: str) -> bool:
    """
    Validate if the string is a valid IPv4 address or CIDR notation.
    
    Args:
        ip_str: IP address string to validate
    
    Returns:
        bool: True if valid IPv4 address or CIDR, False otherwise
    """
    try:
        # Check if it's a CIDR notation
        if '/' in ip_str:
            ipaddress.ip_network(ip_str, strict=False)
        else:
            ipaddress.ip_address(ip_str)
        return True
    except ValueError:
        return False

def process_ip_files(input_dir: str = ".", output_dir: str = "cleaned") -> None:
    """
    Process IP address files by removing duplicates and whitelisted IPs.
    
    Args:
        input_dir: Directory containing the IP files (default: current directory)
        output_dir: Directory where cleaned files will be saved (default: 'cleaned')
    """
    input_path = Path(input_dir).resolve()
    output_path = Path(output_dir).resolve()
    
    print(f"Input directory: {input_path}")
    print(f"Output directory: {output_path}")
    
    # Define file names
    malicious_ip_file = "IPv4Malware.txt"
    whitelist_ip_file = "IPv4WhiteList.txt"
    
    # Print files we're looking for
    print("\nLooking for these files:")
    for file_name in [malicious_ip_file, whitelist_ip_file]:
        file_path = input_path / file_name
        print(f"- {file_name}: {'Found' if file_path.exists() else 'Not found'}")
    
    # Create output directory if it doesn't exist
    output_path.mkdir(exist_ok=True)
    print(f"\nCreated output directory: {output_path}")
    
    # Process whitelist IPs
    whitelist_ips: Set[str] = set()
    whitelist_networks: List[ipaddress.IPv4Network] = []
    
    try:
        with open(input_path / whitelist_ip_file, 'r', encoding='utf-8') as f:
            for line in f:
                ip_str = line.strip()
                if not ip_str or ip_str.startswith('#'):
                    continue
                    
                if validate_ip(ip_str):
                    if '/' in ip_str:
                        # Store CIDR ranges separately
                        whitelist_networks.append(ipaddress.ip_network(ip_str, strict=False))
                    else:
                        whitelist_ips.add(ip_str)
    except FileNotFoundError:
        print(f"Warning: {whitelist_ip_file} not found. Proceeding without whitelist.")
    
    # Process malicious IPs
    malicious_ips: Set[str] = set()
    invalid_ips: List[str] = []
    
    try:
        with open(input_path / malicious_ip_file, 'r', encoding='utf-8') as f:
            for line in f:
                ip_str = line.strip()
                if not ip_str or ip_str.startswith('#'):
                    continue
                
                if validate_ip(ip_str):
                    # Check if IP is in any whitelisted network
                    if '/' in ip_str:
                        network = ipaddress.ip_network(ip_str, strict=False)
                        if not any(network.overlaps(wn) for wn in whitelist_networks):
                            malicious_ips.add(ip_str)
                    else:
                        ip = ipaddress.ip_address(ip_str)
                        if (ip_str not in whitelist_ips and 
                            not any(ip in network for network in whitelist_networks)):
                            malicious_ips.add(ip_str)
                else:
                    invalid_ips.append(ip_str)
    except FileNotFoundError:
        print(f"Warning: {malicious_ip_file} not found.")
    
    # Write processed IPs back to files
    if malicious_ips:
        output_file = output_path / f"cleaned_{malicious_ip_file}"
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(sorted(malicious_ips, 
                key=lambda ip: int(ipaddress.ip_network(ip, strict=False)[0]))))
        print(f"Created {output_file} with {len(malicious_ips)} unique malicious IPs")
    
    if whitelist_ips or whitelist_networks:
        output_file = output_path / f"cleaned_{whitelist_ip_file}"
        with open(output_file, 'w', encoding='utf-8') as f:
            # Write individual IPs first
            if whitelist_ips:
                f.write('\n'.join(sorted(whitelist_ips, 
                    key=lambda ip: int(ipaddress.ip_address(ip)))))
            # Then write networks
            if whitelist_networks:
                if whitelist_ips:
                    f.write('\n')
                f.write('\n'.join(str(network) for network in sorted(whitelist_networks, 
                    key=lambda n: int(n[0]))))
        print(f"Created {output_file} with {len(whitelist_ips)} individual IPs and {len(whitelist_networks)} networks")
    
    # Report invalid IPs if any were found
    if invalid_ips:
        invalid_file = output_path / "invalid_ips.txt"
        with open(invalid_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(invalid_ips))
        print(f"\nWarning: Found {len(invalid_ips)} invalid IP addresses. See {invalid_file}")

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description='Process IP address files and remove duplicates.')
    parser.add_argument('--input-dir', default=".", help='Directory containing IP files')
    parser.add_argument('--output-dir', default="cleaned", help='Directory for cleaned files')
    
    args = parser.parse_args()
    process_ip_files(args.input_dir, args.output_dir)
