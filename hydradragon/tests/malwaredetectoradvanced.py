import ctypes
import time
from ctypes import wintypes
import psutil

# ----------------------------------------------------
# Constants for Windows API calls
# ----------------------------------------------------
WM_GETTEXT = 0x000D
WM_GETTEXTLENGTH = 0x000E
WM_CLOSE = 0x0010

# WinEvent constants to capture live window events
EVENT_OBJECT_CREATE = 0x8000
EVENT_OBJECT_SHOW = 0x8002
EVENT_SYSTEM_DIALOGSTART = 0x0010
EVENT_OBJECT_HIDE = 0x8003
EVENT_OBJECT_NAMECHANGE = 0x800C
WINEVENT_OUTOFCONTEXT = 0x0000

PROCESS_QUERY_LIMITED_INFORMATION = 0x1000

# Load libraries
kernel32 = ctypes.windll.kernel32
user32 = ctypes.windll.user32
ole32 = ctypes.windll.ole32

# ----------------------------------------------------
# Process helper: get PID and executable path of a window
# ----------------------------------------------------

def get_process_path(hwnd):
    """Return the executable path of the process owning the given HWND. Try WinAPI first, fall back to psutil."""
    pid = wintypes.DWORD()
    user32.GetWindowThreadProcessId(hwnd, ctypes.byref(pid))
    if pid.value == 0:
        return "<unknown_pid>"

    # Try using the Windows API
    hproc = kernel32.OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, False, pid.value)
    if hproc:
        try:
            buff_len = wintypes.DWORD(260)
            buff = ctypes.create_unicode_buffer(buff_len.value)
            if kernel32.QueryFullProcessImageNameW(hproc, 0, buff, ctypes.byref(buff_len)):
                return buff.value
        finally:
            kernel32.CloseHandle(hproc)

    # Fallback to psutil
    try:
        proc = psutil.Process(pid.value)
        return proc.exe()
    except psutil.NoSuchProcess:
        return f"<terminated_pid:{pid.value}>"
    except psutil.AccessDenied:
        return f"<access_denied_pid:{pid.value}>"
    except Exception as e:
        return f"<error_pid:{pid.value}:{type(e).__name__}>"

# ----------------------------------------------------
# Helper functions for enumeration
# ----------------------------------------------------

def get_window_text(hwnd):
    """Retrieve the text of a window; always returns a string."""
    length = user32.GetWindowTextLengthW(hwnd) + 1
    buf = ctypes.create_unicode_buffer(length)
    user32.GetWindowTextW(hwnd, buf, length)
    return buf.value or ""

def get_control_text(hwnd):
    """Retrieve text from a control using SendMessageW."""
    length = user32.SendMessageW(hwnd, WM_GETTEXTLENGTH, 0, 0) + 1
    buf = ctypes.create_unicode_buffer(length)
    user32.SendMessageW(hwnd, WM_GETTEXT, length, buf)
    return buf.value or ""

def find_child_windows(parent_hwnd):
    """Find all child windows of the given parent window."""
    child_windows = []
    def _enum_proc(hwnd, lParam):
        child_windows.append(hwnd)
        return True

    EnumChildProc = ctypes.WINFUNCTYPE(ctypes.c_bool, ctypes.c_int, ctypes.c_void_p)
    user32.EnumChildWindows(parent_hwnd, EnumChildProc(_enum_proc), None)
    return child_windows

# --- UI Automation Setup ---
try:
    from comtypes.client import CreateObject
    uia = CreateObject('UIAutomationClient.CUIAutomation')
except Exception:
    uia = None

def get_uia_text(hwnd):
    """Retrieve control text via UI Automation if available."""
    if not uia:
        return ""
    try:
        element = uia.ElementFromHandle(hwnd)
        name = element.CurrentName
        return name or ""
    except Exception:
        return ""

def find_descendant_windows(root_hwnd):
    """Recursively enumerate all descendant windows of a given window."""
    descendants = []
    stack = [root_hwnd]
    while stack:
        parent = stack.pop()
        children = find_child_windows(parent)
        for ch in children:
            descendants.append(ch)
            stack.append(ch)
    return descendants

# ----------------------------------------------------
# Advanced enumeration-based capture
# ----------------------------------------------------

def find_windows_with_text(target_text=None):
    """
    Find all windows with text - no filtering, checks everything.
    Uses multiple text extraction methods including UI Automation.
    If target_text is None, returns all windows with any text.
    """
    window_handles = []
    
    def get_any_text(hwnd):
        """Try multiple methods to get text from a window handle."""
        # 1) Standard window text
        text = get_window_text(hwnd).strip()
        if text:
            return text
        
        # 2) Control text via SendMessage
        text = get_control_text(hwnd).strip() 
        if text:
            return text
            
        # 3) UI Automation fallback
        text = get_uia_text(hwnd).strip()
        if text:
            return text
            
        return ""
    
    def enum_windows_callback(hwnd, lParam):
        # Check the main window text using all methods
        window_text = get_any_text(hwnd)
        if window_text:
            if target_text is None or target_text in window_text:
                process_path = get_process_path(hwnd)
                window_handles.append((hwnd, window_text, process_path, "main_window"))
        
        # Always check all child windows and descendants
        try:
            descendants = find_descendant_windows(hwnd)
            for child in descendants:
                control_text = get_any_text(child)
                if control_text:
                    if target_text is None or target_text in control_text:
                        process_path = get_process_path(child)
                        window_handles.append((child, control_text, process_path, "child_window"))
        except Exception as e:
            # Continue even if there's an error with child enumeration
            pass
        
        return True

    # Enumerate ALL windows (no visibility check - removed IsWindowVisible)
    EnumWindowsProc = ctypes.WINFUNCTYPE(ctypes.c_bool, ctypes.c_int, ctypes.c_void_p)
    user32.EnumWindows(EnumWindowsProc(enum_windows_callback), None)
    return window_handles

def close_window(hwnd):
    """Attempt to close a window gracefully."""
    try:
        user32.PostMessageW(hwnd, WM_CLOSE, 0, 0)
        return True
    except Exception:
        return False

def get_window_class_name(hwnd):
    """Get the class name of a window."""
    class_name = ctypes.create_unicode_buffer(256)
    user32.GetClassNameW(hwnd, class_name, 256)
    return class_name.value

def get_window_rect(hwnd):
    """Get the window rectangle (position and size)."""
    rect = wintypes.RECT()
    user32.GetWindowRect(hwnd, ctypes.byref(rect))
    return rect.left, rect.top, rect.right, rect.bottom

# ----------------------------------------------------
# Main monitoring function
# ----------------------------------------------------

def monitor_windows(target_message, scan_interval=5, show_all_matches=False, auto_close=False):
    """
    Advanced window monitoring with comprehensive scanning.
    
    Args:
        target_message: Text to search for
        scan_interval: Time between scans in seconds
        show_all_matches: If True, shows all windows containing the text
        auto_close: If True, automatically closes matching windows
    """
    print(f"Starting advanced window monitor for: '{target_message}'")
    print(f"Scan interval: {scan_interval} seconds")
    print(f"Auto-close: {'Enabled' if auto_close else 'Disabled'}")
    print("=" * 60)
    
    detected_windows = set()  # Track already detected windows
    
    while True:
        try:
            windows = find_windows_with_text(target_message)
            
            for hwnd, text, process_path, window_type in windows:
                # Create a unique identifier for this window
                window_id = (hwnd, text.strip())
                
                # Only show new detections or if show_all_matches is True
                if window_id not in detected_windows or show_all_matches:
                    detected_windows.add(window_id)
                    
                    # Get additional window info
                    class_name = get_window_class_name(hwnd)
                    left, top, right, bottom = get_window_rect(hwnd)
                    
                    print(f"\n[DETECTION] {window_type.upper()}")
                    print(f"HWND: {hwnd}")
                    print(f"Text: '{text}'")
                    print(f"Class: {class_name}")
                    print(f"Process: {process_path}")
                    print(f"Position: ({left}, {top})")
                    print(f"Size: {right-left}x{bottom-top}")
                    print("-" * 40)
                    
                    # Show system alert
                    try:
                        user32.MessageBoxW(
                            0, 
                            f'Detected target text in {window_type}:\n\n"{text}"\n\nProcess: {process_path}', 
                            'Window Monitor Alert', 
                            0x40  # MB_ICONINFORMATION
                        )
                    except Exception:
                        pass
                    
                    # Auto-close if enabled
                    if auto_close:
                        if close_window(hwnd):
                            print(f"[AUTO-CLOSE] Successfully closed window {hwnd}")
                        else:
                            print(f"[AUTO-CLOSE] Failed to close window {hwnd}")
            
            # Clean up detected_windows set periodically (remove invalid handles)
            if len(detected_windows) > 1000:  # Prevent memory buildup
                valid_windows = set()
                for window_id in detected_windows:
                    hwnd, _ = window_id
                    if user32.IsWindow(hwnd):  # Check if window still exists
                        valid_windows.add(window_id)
                detected_windows = valid_windows
                
        except Exception as e:
            print(f"Error during scan: {e}")
        
        time.sleep(scan_interval)

def main():
    """Main function with enhanced configuration options."""
    # Configuration
    target_message = "This program cannot be run under virtual environment or debugging software"
    scan_interval = 3  # seconds
    show_all_matches = False  # Set to True to see repeated detections
    auto_close = False  # Set to True to automatically close detected windows
    
    print("Advanced Windows Text Monitor")
    print("============================")
    print(f"Target text: '{target_message}'")
    print("\nStarting monitor... Press Ctrl+C to stop.")
    
    try:
        monitor_windows(target_message, scan_interval, show_all_matches, auto_close)
    except KeyboardInterrupt:
        print("\n\nMonitor stopped by user.")
    except Exception as e:
        print(f"\nUnexpected error: {e}")

if __name__ == "__main__":
    main()