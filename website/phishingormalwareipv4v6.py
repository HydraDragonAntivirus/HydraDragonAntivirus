#!/usr/bin/env python3
import os
from pathlib import Path
from typing import Set, List, Dict
import ipaddress

def is_valid_ip(ip_string):
    """
    Validate if the string is a valid public IP address (IPv4/IPv6) or CIDR notation.
    Returns "ipv4", "ipv6" or None if invalid.
    """
    def is_bad_network(net):
        """Check if network is in excluded categories"""
        if net.version == 4:
            return (net.is_private or net.is_loopback 
                    or net.is_link_local or net.is_multicast 
                    or net.is_reserved)
        else:
            return (net.is_loopback or net.is_link_local 
                    or net.is_multicast or net.is_reserved)

    try:
        # Try as network first (CIDR notation)
        net = ipaddress.ip_network(ip_string, strict=False)
        if is_bad_network(net):
            return None
        return "ipv4" if net.version == 4 else "ipv6"
    except ValueError:
        try:
            # Try as single IP address
            ip = ipaddress.ip_address(ip_string)
            if is_bad_network(ip):
                return None
            return "ipv4" if ip.version == 4 else "ipv6"
        except ValueError:
            return None

def validate_ip_syntax(ip_str: str) -> bool:
    """Validate IP/CIDR syntax only (without category checks)"""
    try:
        if '/' in ip_str:
            ipaddress.ip_network(ip_str, strict=False)
        else:
            ipaddress.ip_address(ip_str)
        return True
    except ValueError:
        return False

def convert_filename(filename: str, from_tag: str, to_tag: str) -> str:
    """Replace the version tag in a filename."""
    return filename.replace(from_tag, to_tag)

def process_ip_files(input_dir: str = ".", output_dir: str = "cleaned") -> None:
    """
    Process IP address files (both IPv4 and IPv6) by removing duplicates and whitelisted IPs,
    then applying a priority order for malicious lists.

    For IPv4 the expected files are:
      - IPv4Malware.txt
      - IPv4PhishingActive.txt
      - IPv4PhishingInActive.txt
      - IPv4DDoS.txt
      - IPv4BruteForce.txt
      - IPv4Spam.txt         <-- Spam has lower priority than Malware
      - IPv4WhiteList.txt

    For IPv6 the expected files are:
      - IPv6Malware.txt
      - IPv6PhishingActive.txt
      - IPv6PhishingInActive.txt
      - IPv6DDoS.txt
      - IPv6BruteForce.txt
      - IPv6Spam.txt         <-- Spam has lower priority than Malware
      - IPv6WhiteList.txt

    Priority Order (highest to lowest) for malicious lists:
      1. PhishingActive
      2. PhishingInActive
      3. DDoS
      4. Bruteforce
      5. Spam
      6. Malware

    Wrong-version entries (e.g. an IPv6 IP found in an IPv4 file) are saved
    to a converted output file.
    """
    input_path = Path(input_dir).resolve()
    output_path = Path(output_dir).resolve()

    print(f"Input directory: {input_path}")
    print(f"Output directory: {output_path}")

    # Define file names for each version.
    files_ipv4: Dict[str, str] = {
        "malicious": "IPv4Malware.txt",
        "phishing_active": "IPv4PhishingActive.txt",
        "phishing_inactive": "IPv4PhishingInActive.txt",
        "ddos": "IPv4DDoS.txt",
        "bruteforce": "IPv4BruteForce.txt",
        "spam": "IPv4Spam.txt",
        "whitelist": "IPv4WhiteList.txt"
    }
    files_ipv6: Dict[str, str] = {
        "malicious": "IPv6Malware.txt",
        "phishing_active": "IPv6PhishingActive.txt",
        "phishing_inactive": "IPv6PhishingInActive.txt",
        "ddos": "IPv6DDoS.txt",
        "bruteforce": "IPv6BruteForce.txt",
        "spam": "IPv6Spam.txt",
        "whitelist": "IPv6WhiteList.txt"
    }

    # List all expected files.
    print("\nIPv4 files:")
    for key, fname in files_ipv4.items():
        file_path = input_path / fname
        print(f"- {fname}: {'Found' if file_path.exists() else 'Not found'}")
    print("\nIPv6 files:")
    for key, fname in files_ipv6.items():
        file_path = input_path / fname
        print(f"- {fname}: {'Found' if file_path.exists() else 'Not found'}")

    # Create output directory if needed.
    output_path.mkdir(exist_ok=True)
    print(f"\nCreated output directory: {output_path}")

    # --- Process Whitelist IPs ---
    # For IPv4 whitelist:
    whitelist_ips_v4: Set[str] = set()
    whitelist_networks_v4: List[ipaddress.IPv4Network] = []
    # For IPv6 whitelist:
    whitelist_ips_v6: Set[str] = set()
    whitelist_networks_v6: List[ipaddress.IPv6Network] = []

    # Process IPv4 whitelist:
    try:
        with open(input_path / files_ipv4["whitelist"], 'r', encoding='utf-8') as f:
            for line in f:
                ip_str = line.strip()
                if not ip_str or ip_str.startswith('#'):
                    continue
                # Use syntax validation so that private IPs are accepted in whitelist
                if validate_ip_syntax(ip_str):
                    if '/' in ip_str:
                        try:
                            network = ipaddress.ip_network(ip_str, strict=False)
                        except ValueError:
                            continue
                        if network.version == 4:
                            whitelist_networks_v4.append(network)
                        else:
                            whitelist_networks_v6.append(network)
                    else:
                        ip_obj = ipaddress.ip_address(ip_str)
                        if ip_obj.version == 4:
                            whitelist_ips_v4.add(ip_str)
                        else:
                            whitelist_ips_v6.add(ip_str)
    except FileNotFoundError:
        print(f"Warning: {files_ipv4['whitelist']} not found. Proceeding without IPv4 whitelist.")

    # Process IPv6 whitelist:
    try:
        with open(input_path / files_ipv6["whitelist"], 'r', encoding='utf-8') as f:
            for line in f:
                ip_str = line.strip()
                if not ip_str or ip_str.startswith('#'):
                    continue
                if validate_ip_syntax(ip_str):
                    if '/' in ip_str:
                        try:
                            network = ipaddress.ip_network(ip_str, strict=False)
                        except ValueError:
                            continue
                        if network.version == 6:
                            whitelist_networks_v6.append(network)
                        else:
                            whitelist_networks_v4.append(network)
                    else:
                        ip_obj = ipaddress.ip_address(ip_str)
                        if ip_obj.version == 6:
                            whitelist_ips_v6.add(ip_str)
                        else:
                            whitelist_ips_v4.add(ip_str)
    except FileNotFoundError:
        print(f"Warning: {files_ipv6['whitelist']} not found. Proceeding without IPv6 whitelist.")

    # --- Prepare sets for malicious IPs for each category ---
    # For IPv4:
    phishing_active_v4: Set[str] = set()
    phishing_inactive_v4: Set[str] = set()
    ddos_v4: Set[str] = set()
    bruteforce_v4: Set[str] = set()
    spam_v4: Set[str] = set()
    malware_v4: Set[str] = set()
    # For IPv6:
    phishing_active_v6: Set[str] = set()
    phishing_inactive_v6: Set[str] = set()
    ddos_v6: Set[str] = set()
    bruteforce_v6: Set[str] = set()
    spam_v6: Set[str] = set()
    malware_v6: Set[str] = set()
    invalid_ips: List[str] = []

    def process_file(file_path: Path, cat_v4: Set[str], cat_v6: Set[str]) -> None:
        """Process a malicious file, splitting IPs by version."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    ip_str = line.strip()
                    if not ip_str or ip_str.startswith('#'):
                        continue
                    # Use public-IP validation for malicious lists.
                    ip_ver = is_valid_ip(ip_str)
                    if not ip_ver:
                        invalid_ips.append(ip_str)
                        continue
                    if '/' in ip_str:
                        network = ipaddress.ip_network(ip_str, strict=False)
                        if network.version == 4:
                            if not any(network.overlaps(wn) for wn in whitelist_networks_v4):
                                cat_v4.add(ip_str)
                        else:
                            if not any(network.overlaps(wn) for wn in whitelist_networks_v6):
                                cat_v6.add(ip_str)
                    else:
                        ip_obj = ipaddress.ip_address(ip_str)
                        if ip_obj.version == 4:
                            if (ip_str not in whitelist_ips_v4 and 
                                not any(ip_obj in wn for wn in whitelist_networks_v4)):
                                cat_v4.add(ip_str)
                        else:
                            if (ip_str not in whitelist_ips_v6 and 
                                not any(ip_obj in wn for wn in whitelist_networks_v6)):
                                cat_v6.add(ip_str)
        except FileNotFoundError:
            print(f"Warning: {file_path.name} not found.")

    # Process malicious files for IPv4:
    process_file(input_path / files_ipv4["phishing_active"], phishing_active_v4, set())
    process_file(input_path / files_ipv4["phishing_inactive"], phishing_inactive_v4, set())
    process_file(input_path / files_ipv4["ddos"], ddos_v4, set())
    process_file(input_path / files_ipv4["bruteforce"], bruteforce_v4, set())
    process_file(input_path / files_ipv4["spam"], spam_v4, set())
    process_file(input_path / files_ipv4["malicious"], malware_v4, set())

    # Process malicious files for IPv6:
    process_file(input_path / files_ipv6["phishing_active"], set(), phishing_active_v6)
    process_file(input_path / files_ipv6["phishing_inactive"], set(), phishing_inactive_v6)
    process_file(input_path / files_ipv6["ddos"], set(), ddos_v6)
    process_file(input_path / files_ipv6["bruteforce"], set(), bruteforce_v6)
    process_file(input_path / files_ipv6["spam"], set(), spam_v6)
    process_file(input_path / files_ipv6["malicious"], set(), malware_v6)

    # --- Apply Priority Ordering for malicious lists separately for IPv4 and IPv6 ---
    # IPv4 Priority Order: 1. PhishingActive, 2. PhishingInactive, 3. DDoS, 4. Bruteforce, 5. Spam, 6. Malware
    bruteforce_v4 -= phishing_active_v4
    bruteforce_v4 -= phishing_inactive_v4
    bruteforce_v4 -= ddos_v4

    spam_v4 -= phishing_active_v4
    spam_v4 -= phishing_inactive_v4
    spam_v4 -= ddos_v4
    spam_v4 -= bruteforce_v4

    malware_v4 -= phishing_active_v4
    malware_v4 -= phishing_inactive_v4
    malware_v4 -= ddos_v4
    malware_v4 -= bruteforce_v4
    malware_v4 -= spam_v4

    # IPv6 Priority Order: same as IPv4:
    bruteforce_v6 -= phishing_active_v6
    bruteforce_v6 -= phishing_inactive_v6
    bruteforce_v6 -= ddos_v6

    spam_v6 -= phishing_active_v6
    spam_v6 -= phishing_inactive_v6
    spam_v6 -= ddos_v6
    spam_v6 -= bruteforce_v6

    malware_v6 -= phishing_active_v6
    malware_v6 -= phishing_inactive_v6
    malware_v6 -= ddos_v6
    malware_v6 -= bruteforce_v6
    malware_v6 -= spam_v6

    # --- Write Output Files ---
    def write_ips(filename: str, ip_set: Set[str]) -> None:
        if ip_set:
            out_file = output_path / filename
            with open(out_file, 'w', encoding='utf-8') as f:
                sorted_ips = sorted(ip_set, key=lambda ip: int(ipaddress.ip_network(ip, strict=False)[0]))
                f.write('\n'.join(sorted_ips))
            print(f"Created {out_file} with {len(ip_set)} IPs")

    # Write IPv4 malicious files:
    write_ips(f"cleaned_{files_ipv4['phishing_active']}", phishing_active_v4)
    write_ips(f"cleaned_{files_ipv4['phishing_inactive']}", phishing_inactive_v4)
    write_ips(f"cleaned_{files_ipv4['ddos']}", ddos_v4)
    write_ips(f"cleaned_{files_ipv4['bruteforce']}", bruteforce_v4)
    write_ips(f"cleaned_{files_ipv4['spam']}", spam_v4)
    write_ips(f"cleaned_{files_ipv4['malicious']}", malware_v4)
    # Write converted (wrong-version) IPv6 malicious files (convert tag: IPv4 -> IPv6)
    write_ips(convert_filename(f"cleaned_{files_ipv4['phishing_active']}", "IPv4", "IPv6"), phishing_active_v6)
    write_ips(convert_filename(f"cleaned_{files_ipv4['phishing_inactive']}", "IPv4", "IPv6"), phishing_inactive_v6)
    write_ips(convert_filename(f"cleaned_{files_ipv4['ddos']}", "IPv4", "IPv6"), ddos_v6)
    write_ips(convert_filename(f"cleaned_{files_ipv4['bruteforce']}", "IPv4", "IPv6"), bruteforce_v6)
    write_ips(convert_filename(f"cleaned_{files_ipv4['spam']}", "IPv4", "IPv6"), spam_v6)
    write_ips(convert_filename(f"cleaned_{files_ipv4['malicious']}", "IPv4", "IPv6"), malware_v6)

    # Write whitelist outputs:
    def write_whitelist(filename: str, ip_set: Set[str], networks: List[ipaddress._BaseNetwork]) -> None:
        if ip_set or networks:
            out_file = output_path / filename
            with open(out_file, 'w', encoding='utf-8') as f:
                lines = []
                if ip_set:
                    sorted_ips = sorted(ip_set, key=lambda ip: int(ipaddress.ip_address(ip)))
                    lines.extend(sorted_ips)
                if networks:
                    if lines:
                        lines.append('')
                    sorted_nets = sorted(networks, key=lambda net: int(net.network_address))
                    lines.extend(str(net) for net in sorted_nets)
                f.write('\n'.join(lines))
            print(f"Created {out_file}")
            
    # Whitelist for IPv4:
    write_whitelist(f"cleaned_{files_ipv4['whitelist']}", whitelist_ips_v4, whitelist_networks_v4)
    # Whitelist for IPv6 (convert tag if needed):
    write_whitelist(convert_filename(f"cleaned_{files_ipv4['whitelist']}", "IPv4", "IPv6"), whitelist_ips_v6, whitelist_networks_v6)

    # Report invalid IPs
    if invalid_ips:
        invalid_file = output_path / "invalid_ips.txt"
        with open(invalid_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(invalid_ips))
        print(f"\nWarning: Found {len(invalid_ips)} invalid IP addresses. See {invalid_file}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description="Process IPv4 and IPv6 IP files (malware, phishing, ddos, bruteforce, spam, whitelist) with version checking. "
                    "If a wrong-version IP is detected in a file, it is saved to a converted output file. "
                    "Priority ordering for malicious lists (highest to lowest): "
                    "PhishingActive > PhishingInActive > DDoS > Bruteforce > Spam > Malware."
    )
    parser.add_argument('--input-dir', default=".", help="Directory containing IP files")
    parser.add_argument('--output-dir', default="cleaned", help="Directory for cleaned files")
    
    args = parser.parse_args()
    process_ip_files(args.input_dir, args.output_dir)
