#!/usr/bin/env python3
import os
from pathlib import Path
from typing import Set, List
import ipaddress

def validate_ip(ip_str: str) -> bool:
    """
    Validate if the string is a valid IP address (IPv4 or IPv6) or CIDR notation.
    """
    try:
        if '/' in ip_str:
            ipaddress.ip_network(ip_str, strict=False)
        else:
            ipaddress.ip_address(ip_str)
        return True
    except ValueError:
        return False

def convert_filename(filename: str, from_tag: str, to_tag: str) -> str:
    """Replace the version tag in a filename."""
    return filename.replace(from_tag, to_tag)

def process_ip_files(input_dir: str = ".", output_dir: str = "cleaned") -> None:
    """
    Process IPv4 IP address files by removing duplicates, whitelisted IPs,
    and applying a priority order. Also, if a wrong-version (IPv6) IP is
    detected in an IPv4 file, save it to a separate file with the tag converted.

    Input files (expected to be IPv4):
      - IPv4Malware.txt
      - IPv4PhishingActive.txt
      - IPv4PhishingInActive.txt
      - IPv4BotNet.txt       <-- Added: BotNet with high priority after phishing
      - IPv4BruteForce.txt
      - IPv4WhiteList.txt

    Priority Order (highest to lowest) for malicious lists:
      1. PhishingActive
      2. PhishingInActive
      3. BotNet
      4. BruteForce
      5. Malware

    Args:
        input_dir: Directory containing the IP files.
        output_dir: Directory where cleaned files will be saved.
    """
    input_path = Path(input_dir).resolve()
    output_path = Path(output_dir).resolve()

    print(f"Input directory: {input_path}")
    print(f"Output directory: {output_path}")

    # Define file names (for malicious lists and whitelist)
    malicious_ip_file       = "IPv4Malware.txt"
    phishing_active_file    = "IPv4PhishingActive.txt"
    phishing_inactive_file  = "IPv4PhishingInActive.txt"
    botnet_file             = "IPv4BotNet.txt"       # New file
    bruteforce_ip_file      = "IPv4BruteForce.txt"
    whitelist_ip_file       = "IPv4WhiteList.txt"

    all_files = [malicious_ip_file, phishing_active_file, phishing_inactive_file, botnet_file, bruteforce_ip_file, whitelist_ip_file]
    print("\nLooking for these files:")
    for file_name in all_files:
        file_path = input_path / file_name
        print(f"- {file_name}: {'Found' if file_path.exists() else 'Not found'}")

    # Create output directory if needed
    output_path.mkdir(exist_ok=True)
    print(f"\nCreated output directory: {output_path}")

    # --- Process Whitelist IPs ---
    # Separate whitelist entries by version:
    whitelist_ips_v4: Set[str] = set()
    whitelist_networks_v4: List[ipaddress.IPv4Network] = []
    whitelist_ips_v6: Set[str] = set()
    whitelist_networks_v6: List[ipaddress.IPv6Network] = []

    try:
        with open(input_path / whitelist_ip_file, 'r', encoding='utf-8') as f:
            for line in f:
                ip_str = line.strip()
                if not ip_str or ip_str.startswith('#'):
                    continue
                if validate_ip(ip_str):
                    if '/' in ip_str:
                        try:
                            network = ipaddress.ip_network(ip_str, strict=False)
                        except ValueError:
                            continue
                        if network.version == 4:
                            whitelist_networks_v4.append(network)
                        else:
                            whitelist_networks_v6.append(network)
                    else:
                        ip_obj = ipaddress.ip_address(ip_str)
                        if ip_obj.version == 4:
                            whitelist_ips_v4.add(ip_str)
                        else:
                            whitelist_ips_v6.add(ip_str)
    except FileNotFoundError:
        print(f"Warning: {whitelist_ip_file} not found. Proceeding without whitelist.")

    # --- Prepare sets for malicious IPs ---
    # For each category, we maintain two sets: one for correct (IPv4) and one for wrong (IPv6)
    phishing_active_v4, phishing_active_v6 = set(), set()
    phishing_inactive_v4, phishing_inactive_v6 = set(), set()
    botnet_v4, botnet_v6 = set(), set()            # New: BotNet sets
    bruteforce_v4, bruteforce_v6 = set(), set()
    malware_v4, malware_v6 = set(), set()
    invalid_ips: List[str] = []

    def process_file(file_path: Path, cat_v4: Set[str], cat_v6: Set[str]) -> None:
        """Process a malicious file, splitting IPs by version."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    ip_str = line.strip()
                    if not ip_str or ip_str.startswith('#'):
                        continue
                    if not validate_ip(ip_str):
                        invalid_ips.append(ip_str)
                        continue
                    # If CIDR notation:
                    if '/' in ip_str:
                        network = ipaddress.ip_network(ip_str, strict=False)
                        if network.version == 4:
                            # For CIDR, check against IPv4 whitelist networks
                            if not any(network.overlaps(wn) for wn in whitelist_networks_v4):
                                cat_v4.add(ip_str)
                        else:  # IPv6 detected in an IPv4 file!
                            if not any(network.overlaps(wn) for wn in whitelist_networks_v6):
                                cat_v6.add(ip_str)
                    else:
                        ip_obj = ipaddress.ip_address(ip_str)
                        if ip_obj.version == 4:
                            if (ip_str not in whitelist_ips_v4 and 
                                not any(ip_obj in wn for wn in whitelist_networks_v4)):
                                cat_v4.add(ip_str)
                        else:
                            if (ip_str not in whitelist_ips_v6 and 
                                not any(ip_obj in wn for wn in whitelist_networks_v6)):
                                cat_v6.add(ip_str)
        except FileNotFoundError:
            print(f"Warning: {file_path.name} not found.")

    # Process each malicious file by category:
    process_file(input_path / phishing_active_file, phishing_active_v4, phishing_active_v6)
    process_file(input_path / phishing_inactive_file, phishing_inactive_v4, phishing_inactive_v6)
    process_file(input_path / botnet_file, botnet_v4, botnet_v6)
    process_file(input_path / bruteforce_ip_file, bruteforce_v4, bruteforce_v6)
    process_file(input_path / malicious_ip_file, malware_v4, malware_v6)

    # --- Apply Priority Ordering for malicious lists (separately for each version) ---
    # New Priority for IPv4: 1. PhishingActive, 2. PhishingInActive, 3. BotNet, 4. BruteForce, 5. Malware
    # For IPv4:
    bruteforce_v4 -= phishing_active_v4
    bruteforce_v4 -= phishing_inactive_v4
    bruteforce_v4 -= botnet_v4

    malware_v4 -= phishing_active_v4
    malware_v4 -= phishing_inactive_v4
    malware_v4 -= botnet_v4
    malware_v4 -= bruteforce_v4

    # For IPv6 (similarly):
    bruteforce_v6 -= phishing_active_v6
    bruteforce_v6 -= phishing_inactive_v6
    bruteforce_v6 -= botnet_v6

    malware_v6 -= phishing_active_v6
    malware_v6 -= phishing_inactive_v6
    malware_v6 -= botnet_v6
    malware_v6 -= bruteforce_v6

    # --- Write Output Files ---
    def write_ips(filename: str, ip_set: Set[str]) -> None:
        if ip_set:
            out_file = output_path / filename
            with open(out_file, 'w', encoding='utf-8') as f:
                # Sorting: convert the first address of each IP/network to an integer.
                sorted_ips = sorted(ip_set, key=lambda ip: int(ipaddress.ip_network(ip, strict=False)[0]))
                f.write('\n'.join(sorted_ips))
            print(f"Created {out_file} with {len(ip_set)} IPs")

    # Write correct IPv4 malicious files (using original file names)
    write_ips(f"cleaned_{phishing_active_file}", phishing_active_v4)
    write_ips(f"cleaned_{phishing_inactive_file}", phishing_inactive_v4)
    write_ips(f"cleaned_{botnet_file}", botnet_v4)
    write_ips(f"cleaned_{bruteforce_ip_file}", bruteforce_v4)
    write_ips(f"cleaned_{malicious_ip_file}", malware_v4)
    # Write wrong-version (IPv6) malicious files (convert tag: IPv4 -> IPv6)
    write_ips(convert_filename(f"cleaned_{phishing_active_file}", "IPv4", "IPv6"), phishing_active_v6)
    write_ips(convert_filename(f"cleaned_{phishing_inactive_file}", "IPv4", "IPv6"), phishing_inactive_v6)
    write_ips(convert_filename(f"cleaned_{botnet_file}", "IPv4", "IPv6"), botnet_v6)
    write_ips(convert_filename(f"cleaned_{bruteforce_ip_file}", "IPv4", "IPv6"), bruteforce_v6)
    write_ips(convert_filename(f"cleaned_{malicious_ip_file}", "IPv4", "IPv6"), malware_v6)

    # Write whitelist outputs separately by version.
    def write_whitelist(filename: str, ip_set: Set[str], networks: List[ipaddress._BaseNetwork]) -> None:
        if ip_set or networks:
            out_file = output_path / filename
            with open(out_file, 'w', encoding='utf-8') as f:
                lines = []
                if ip_set:
                    sorted_ips = sorted(ip_set, key=lambda ip: int(ipaddress.ip_address(ip)))
                    lines.extend(sorted_ips)
                if networks:
                    if lines:
                        lines.append('')
                    # Sort networks by network address.
                    sorted_nets = sorted(networks, key=lambda net: int(net.network_address))
                    lines.extend(str(net) for net in sorted_nets)
                f.write('\n'.join(lines))
            print(f"Created {out_file}")
            
    # Whitelist for IPv4 entries:
    write_whitelist(f"cleaned_{whitelist_ip_file}", whitelist_ips_v4, whitelist_networks_v4)
    # Whitelist for wrong-version (IPv6) entries:
    write_whitelist(convert_filename(f"cleaned_{whitelist_ip_file}", "IPv4", "IPv6"), whitelist_ips_v6, whitelist_networks_v6)

    # Report invalid IPs
    if invalid_ips:
        invalid_file = output_path / "invalid_ips.txt"
        with open(invalid_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(invalid_ips))
        print(f"\nWarning: Found {len(invalid_ips)} invalid IP addresses. See {invalid_file}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Process IPv4 IP files (malware, phishing, botnet, bruteforce, whitelist) with version checking. "
                                                 "If an IPv6 IP is detected in an IPv4 file, it is saved to a converted output file. "
                                                 "IPv4BotNet.txt is added with high priority (after phishing).")
    parser.add_argument('--input-dir', default=".", help="Directory containing IP files")
    parser.add_argument('--output-dir', default="cleaned", help="Directory for cleaned files")
    
    args = parser.parse_args()
    process_ip_files(args.input_dir, args.output_dir)
